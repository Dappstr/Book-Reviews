

Chapter one, good review of function parameter type deduction, specifically relating to cv-qualification along with pointers and arrays. It also goes into the difference between template type deduction and auto type deduction, along with decltype rules.

Chapter two goes into good uses of the auto type deduction, and in my opinion, how programmers should adhere to the AAA(Almost Always Auto) philosophy. Meyers goes into decent examples of where even when a programmer may want a specific type declared, there are a lot of times, and cases, where auto would be easier to write, as well as being much more efficient for compilation. Scott also briefly goes into the wild world of a vector of booleans. Very expressive writer. Numerous uses of the d*mn word in just chapter two.

Chapter three goes into more modern C++ concepts, so this can be seen as a bit of an upgrade compared to Meyers' previous "Effective C++" book. This includes things such as preference of scoped to unscoped enums, deleted special member functions over private member functions, additional STL functions (std::get, std::underlying_type::type, std::atomic, et cetera), briefly goes over mutexes but not really a thorough explanation, along with some other good practices that were established in C++11/14. I would recommend having a basic understanding of what std::atomic and std::mutex are, as some of this chapter goes into making const member functions thread safe, and doing so by using mutexes and std::atomic as a possible more advantageous approach in some scenarios.

Chapter four goes into smart pointers of course being a book that is designed to introduce new features of C++11/14. The chapter first goes into why it's hard to love raw pointers and their shortcomings, and then starts with an introduction of unique_ptr. This is already an improvement from the introduction of auto_ptr in the previous book. Along with the introduction of these smart pointers, the chapter also goes into when make_shared may not be usable.

The fifth chapter goes into move semantics and it's a pretty thick chapter almost as long as chapter three. The chapter begins by deconstructing a couple fallacies that people who're new to move semantics may believe. std::move does not actually move anything, nor does std::forward forward anything. What these template functions do depends entirely on implementation. Meyers uses the term "universal reference" which I've discussed why the standards committee chooses "forwarding reference" over this in my review of Josuttis' move semantics book. This chapter does a pretty decent job of distinguishing contextual differences between the use of two ampersands. It also introduces the cool concept of SFINAE. This chapter also does a good job of covering reference collapsing. Cases where perfect forwarding can fail is also addressed with the example of un-universally portable code, where we attempt to forward static const or constexpr data members that do not have a definition. The solution in the book is to initialize the data member. Lastly it goes into forwarding bit fields (which I didn't have any knowledge of what bit fields are or were used for prior) and how they can be a source of perfect forwarding failure.

Chapter six which goes into lambdas/closures, their benefits, misconceptions, et cetera. A couple of these, being downfalls of default by-value and by-reference capturing, leading to dangling pointers within your code, along with introducing init capture as a possible remedy although noting that C++11 users will unfortunately have no ability to use this feature. Lastly, the chapter goes over the redundancy of std::bind in today's world with the ability of lambdas.

Chapter seven covers concurrency. Concurrency is not something I'm too familiar with at the current time of writing this. The chapter starts off by introducing two ideas, thread-based programming, and task-based programming. The chapter covers the advantages of asynchronosity via std::async (task-based) and std::thread (thread-based), such as the get function from the returned future, which is especially important if what's being done throws an exception.

I'm uploading this review unfinished; as of now I don't have quite the amount of experience with concurrence that I'd like with concurrency in order to more fully review the seventh chapter. I have a more up to date book that's entirely focused on concurrency so I'll be reading that before finishing this review. Overall so far from the majority of the book I've read, it's incredibly well put together and I'll very much be keeping it as a refresher for certain things.
